import math

import numpy as np

import utilities as ut


class TrioModel(object):
    """
    A TrioModel object contains parameters, which are constant throughout the
    trio model. They are a scalar between [0, 1].

    Attributes:
        reads: A 3 x 4 matrix nt count lists for child, mom, and dad
            [[#A, #C, #G, #T], [#A, #C, #G, #T], [#A, #C, #G, #T]].
        pop_muta_rate: A number representing the population mutation rate
            (theta).
        germ_muta_rate: A number representing the germline mutation rate.
        soma_muta_rate: A number representing the somatic mutation rate.
        seq_err_rate: A number representing the sequencing error rate.
        dm_disp: A value representing the Dirichlet multinomial dispersion.
        dm_bias: A value representing the Dirichlet multinomial bias.
        max_elems: A 1 x 3 array containing the greatest elements in the
            vectors calculated by seq_err in order to scale back to log space.
        geno: A 1 x 16 probability matrix of one parent dynamically derived
            from parent_prob_mat.
        parent_prob_mat: A 16 x 16 probability matrix of the parents in
            log space (see pop_sample).

    """

    def __init__(self, reads=None,
                 pop_muta_rate=0, germ_muta_rate=0, soma_muta_rate=0,
                 seq_err_rate=0, dm_disp=None, dm_bias=None):
        """
        Initializes the given parameters or to 0 for rates and None for
        Dirichlet multinomial parameters if none are given. parent_prob_mat is
        dynamically generated by pop_sample given its mutation rate.
        """
        self.reads = reads
        self.pop_muta_rate = pop_muta_rate
        self.germ_muta_rate = germ_muta_rate
        self.soma_muta_rate = soma_muta_rate
        self.seq_err_rate = seq_err_rate
        self.dm_disp = dm_disp
        self.dm_bias = dm_bias
        self.max_elems = []
        self.geno = None
        self.parent_prob_mat = self.pop_sample()

    def trio(self):
        """
        Implement the trio model for a single site by calling the functions
        on the left of the following diagram. The function names label
        the arrow-denoted processes in the population model.

                              Population          Population
        pop_sample                |                   |
                                  v                   v
                                Mother              Father
                                Zygotic             Zygotic
                                Diploid             Diploid
                                Genotype            Genotype
        germ_muta                 |   \             / |  
                                  |    v           v  |
                                  |      Daughter     |
                                  |      Diploid      |
        soma_muta                 |         |         |
                                  v         v         v
                                Mother   Daughter  Father
                                Somatic  Somatic   Somatic
                                Diploid  Diploid   Diploid
                                Genotype Genotype  Genotype
        seq_error                 |         |         |
                                  v         v         v
                                Mother   Daughter  Father
                                Genotype Genotype  Genotype
                                Reads    Reads     Reads

        Returns:
            A scalar probability of a mutation given read data and parameters.
        """
        # germline mutation probability, trans matrix
        child_prob_mat = self.get_child_prob_mat()  # 16x256

        # somatic mutation probability, trans matrix
        soma_and_geno_prob_mat = self.soma_and_geno()  # 16x16

        # sequencing error probability
        seq_prob_mat = self.seq_err_all()  # 3x16

        # multiply vectors by transition matrix
        child_prob = seq_prob_mat[0].dot(soma_and_geno_prob_mat)  # 16
        mom_prob = seq_prob_mat[1].dot(soma_and_geno_prob_mat)  # 16
        dad_prob = seq_prob_mat[2].dot(soma_and_geno_prob_mat)  # 16

        # calculate denominator
        child_germ_prob = child_prob.dot(child_prob_mat)  # 1x256
        parent_prob = np.kron(dad_prob, mom_prob)
        half_step_mat = np.multiply(child_germ_prob, self.parent_prob_mat)
        full_step_mat = np.multiply(half_step_mat, parent_prob)
        reads_given_params_proba = np.sum(full_step_mat)
        
        # TODO: calculate numerator
        no_muta_proba = 0

        no_muta_given_reads_proba = no_muta_proba/reads_given_params_proba
        return 1-no_muta_given_reads_proba

    def seq_err(self, member):
        """
        Calculate the probability of sequencing error. Assume each chromosome
        is equally-likely to be sequenced.

        The probability is drawn from a Dirichlet multinomial distribution:
        This is a point of divergence from the Cartwright et al. paper
        mentioned in the other functions.

        When the Dirichlet multinomial is called, the max element is stored in
        this so that we can manipulate the scaling of the probability matrix
        later.

        Args:
            member: The index of the reads for a certain family member in the
                trio model.

        Returns:
            A 1 x 16 probability vector that needs to be multiplied by a
            transition matrix.
        """
        # TODO: add bias when alpha freq are added
        alpha_mat = np.array(ut.ALPHAS * self.seq_err_rate)
        if self.dm_disp is not None:
            alpha_mat *= self.dm_disp

        prob_read_given_soma = np.zeros((ut.GENOTYPE_COUNT))
        for i, alpha in enumerate(alpha_mat):
            log_proba = ut.dirichlet_multinomial(alpha, self.reads[member])
            prob_read_given_soma[i] = log_proba

        prob_read_given_soma_rescaled, max_elem = ut.rescale_to_normal(
            prob_read_given_soma
        )
        self.max_elems.append(max_elem)

        return prob_read_given_soma_rescaled

    def seq_err_all(self):
        """
        Calculate the probability of sequencing error for all reads.

        Returns:
            A 3 x 16 probability matrix given that reads is a 3 x 4 array.
        """
        read_count = len(self.reads)
        seq_prob_mat = np.zeros(( read_count, ut.GENOTYPE_COUNT ))
        for i in range(read_count):
            seq_prob_mat[i] = self.seq_err(i)
        return seq_prob_mat

    def soma_muta(self, soma, chrom):
        """
        Calculate the probability of somatic mutation.

        Terms refer to that of equation 5 on page 7 of Cartwright et al.:
        Family-Based Method for Capturing De Novo Mutations.

        http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3728889/

        Args:
            soma1: A nucleotide character.
            chrom1: Another nucleotide chracter to be compared.

        Returns:
            The probability of somatic mutation.
        """
        exp_term = np.exp(-4.0/3.0 * self.soma_muta_rate)
        term1 = 0.25 - 0.25 * exp_term
        # term2 is indicator term

        # check if indicator function is true for each chromosome
        ind_term_chrom1 = exp_term if soma == chrom else 0

        return term1 + ind_term_chrom1

    def get_soma_vec(self):
        """
        Compute event space for somatic nucleotide given a genotype nucleotide
        for a single chromosome.

        Returns:
            A 4 x 4 probability vector.
        """
        prob_vec = np.zeros(( ut.NUCLEOTIDE_COUNT, ut.NUCLEOTIDE_COUNT ))
        for soma_nt, i in ut.NUCLEOTIDE_INDEX.items():
            for geno_nt, j in ut.NUCLEOTIDE_INDEX.items():
                prob_vec[i, j] = self.soma_muta(soma_nt, geno_nt)
        return prob_vec

    def join_soma(self, soma_given_geno):
        """
        Compute the joint probabilities.

        Args:
            soma_given_geno: A 16 x 16 matrix where the first dimension is the
                lexicographically ordered pairs of letters from nt alphabet
                for somatic genotypes and second dimension is that for true
                genotypes.

        Returns:
            A 16 x 16 probability matrix.
        """
        soma_and_geno = np.zeros(( ut.GENOTYPE_COUNT, ut.GENOTYPE_COUNT ))
        for i in range(ut.GENOTYPE_COUNT):
            soma_and_geno[:, i] = self.geno[i] * soma_given_geno[:, i]
        return soma_and_geno

    def soma_and_geno(self):
        """
        Combine event spaces for two chromosomes (independent of each other)
        and calculate somatic mutation probability matrix for a single parent.

        Returns:
            A 16 x 16 matrix where the first dimension is the
            lexicographically ordered pairs of letters from nt alphabet for
            somatic genotypes and second dimension is that for true genotypes.
        """
        prob_vec = self.get_soma_vec()
        soma_given_geno = np.zeros(( ut.GENOTYPE_COUNT, ut.GENOTYPE_COUNT ))
        for chrom1, i in ut.NUCLEOTIDE_INDEX.items():
            given_chrom1_vec = prob_vec[:, i]
            for chrom2, j in ut.NUCLEOTIDE_INDEX.items():
                given_chrom2_vec = prob_vec[:, i]
                soma_muta_index = i * ut.NUCLEOTIDE_COUNT + j
                outer_prod = np.outer(given_chrom1_vec, given_chrom2_vec)
                outer_prod_flat = outer_prod.flatten()
                soma_given_geno[:, soma_muta_index] = outer_prod_flat

        return self.join_soma(soma_given_geno)

    def germ_muta(self, child_chrom, mom_chrom, dad_chrom, no_muta):
        """
        Calculate the probability of germline mutation and parent chromosome 
        donation in the same step. Assume the first chromosome is associated
        with the mother and the second chromosome is associated with the
        father.

        Args:
            child_chrom: The 2-allele genotype string of the child.
            mom_chrom: The 2-allele genotype string of the mother.
            dad_chrom: The 2-allele genotype string of the father.

        Returns:
            The probability of germline mutation.
        """
        exp_term = math.exp(-4.0/3.0 * self.germ_muta_rate)
        homo_match = 0.25 + 0.75 * exp_term
        hetero_match = 0.25 + 0.25 * exp_term
        no_match = 0.25 - 0.25 * exp_term

        def get_term_match(child_chrom_base, parent_chrom, no_muta):
            if child_chrom_base in parent_chrom:
                if parent_chrom[0] == parent_chrom[1]:
                    return homo_match
                else:
                    return hetero_match if no_muta is False else hetero_match/2
            else:
                return no_match if no_muta is False else 0

        term1 = get_term_match(child_chrom[0], mom_chrom, no_muta)
        term2 = get_term_match(child_chrom[1], dad_chrom, no_muta)
        return term1 * term2

    def get_child_prob_mat(self, no_muta=False):
        """
        Calculate the probability matrix for the offspring given the
        probability matrix of the parents and mutation rate.

        Returns:
            A 16 x 256 probability matrix.
        """
        child_prob_mat = np.zeros((
            ut.GENOTYPE_COUNT,
            ut.GENOTYPE_COUNT * ut.GENOTYPE_COUNT
        ))

        for mother_gt, mom_idx in ut.GENOTYPE_INDEX.items():
            for father_gt, dad_idx in ut.GENOTYPE_INDEX.items():
                for child_gt, child_idx in ut.GENOTYPE_INDEX.items():
                    child_given_parent = self.germ_muta(
                        child_gt,
                        mother_gt,
                        father_gt,
                        no_muta
                    )
                    # mom is first parent
                    flat_idx = mom_idx*ut.GENOTYPE_COUNT + dad_idx
                    parent = self.parent_prob_mat[flat_idx]
                    event = child_given_parent * parent
                    child_prob_mat[child_idx, flat_idx] = event

        return child_prob_mat

    def pop_sample(self):
        """
        The multinomial component of the model generates the nucleotide
        frequency parameter vector (alpha_A, alpha_C, alpha_G, alpha_T) based
        on the nucleotide count input data.

        Probabilities are drawn from a Dirichlet multinomial distribution.
        The Dirichlet component of our models uses this frequency parameter
        vector in addition to the mutation rate (theta), nucleotide
        frequencies [alpha_A, alpha_C, alpha_G, alpha_T], and genome
        nucleotide counts [n_A, n_C, n_G, n_T].

        For example: The genome mutation rate (theta) may be the small scalar
        quantity \theta = 0.00025, the frequency parameter vector
        (alpha_A, alpha_C, alpha_G, alpha_T) = (0.25, 0.25, 0.25, 0.25),
        the genome nucleotide counts (n_A, n_C, n_G, n_T) = (4, 0, 0, 0), for
        the event that both the mother and the father have genotype AA,
        resulting in N = 4.

        Note: This model does not follow that of the Cartwright paper
        mentioned in other functions.

        Set geno as the 1 x 16 probability matrix for a single parent.

        Returns:
            A 1 x 256 probability matrix in log e space where the (i, j)
            element in the matrix is the probability that the mother has
            genotype i and the father has genotype j where i, j in
            {AA, AC, AG, AT, 
             CA, CC, CG, CT,
             GA, GC, GG, GT,
             TA, TC, TG, TT}.

            The matrix is an order-relevant representation of the possible
            events in the sample space that covers all possible parent
            genotype combinations. For example:

            [P(AAAA), P(AAAC), P(AAAG), P(AAAT), P(AACA), P(AACC), P(AACG)...]
        """
        # combine parameters for call to dirichlet multinomial
        muta_nt_freq = np.array([0.25 * self.pop_muta_rate for i in range(4)])
        gt_count = ut.two_parent_counts()
        prob_mat = np.zeros(( ut.GENOTYPE_COUNT, ut.GENOTYPE_COUNT ))
        for i in range(ut.GENOTYPE_COUNT):
            for j in range(ut.GENOTYPE_COUNT):
                nt_count = gt_count[i, j, :]  # count per 2-allele genotype
                log_proba = ut.dirichlet_multinomial(muta_nt_freq, nt_count)
                prob_mat[i, j] = np.exp(log_proba)

        self.geno = np.sum(prob_mat, axis=0)  # set one parent prob mat
        return prob_mat.flatten()